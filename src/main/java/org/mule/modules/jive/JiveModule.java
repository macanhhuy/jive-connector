/**
 * Mule Development Kit Copyright 2010-2011 (c) MuleSoft, Inc. All rights
 * reserved. http://www.mulesoft.com
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

/**
 * This file was automatically generated by the Mule Development Kit
 */
package org.mule.modules.jive;

import static javax.xml.stream.XMLStreamConstants.*;

import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Module;
import org.mule.api.annotations.Processor;

import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.ClientResponse;
import com.sun.jersey.api.client.WebResource;
import com.sun.jersey.api.client.config.ClientConfig;
import com.sun.jersey.api.client.config.DefaultClientConfig;

import java.io.Reader;
import java.io.StringReader;
import java.io.StringWriter;
import java.io.Writer;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Stack;

import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;

import org.apache.commons.lang.UnhandledException;
import org.apache.commons.lang.Validate;

/***/
@Module(name = "jive",
    namespace = "http://repository.mulesoft.org/releases/org/"
              + "mule/modules/mule-module-jive",
    schemaLocation = "http://repository.mulesoft.org/releases/org/"
                   + "mule/modules/mule-module-jive/1.0-SNAPSHOT/mule-jive.xsd")

public class JiveModule implements JiveFacade {
    /**The jersey webresource to access rest resources.*/
    private WebResource gateway;

    /**JiveConnector.
     * @param gatewayUri The base uri
     * */
    public JiveModule(final String gatewayUri) {
        this.createGateway(gatewayUri, createClient());
    }

    /***/
    @Configurable
    private String myProperty;

    /**
     * @param myProperty myProperty
     * */
    public final void setMyProperty(final String myProperty) {
        this.myProperty = myProperty;
    }

    /***/
    @Processor
    public String myProcessor(final String content) {
        /*
         * MESSAGE PROCESSOR CODE GOES HERE
         */

        return content;
    }

    /**XML output factory to write xml.
     * */
    private final XMLOutputFactory xmlOutputFactory =
        XMLOutputFactory.newInstance();

    /**XML input factory to read xml.
     * */
    private final XMLInputFactory xmlInputFactory =
        XMLInputFactory.newInstance();


    /* Creates an entity.
     * @see org.mule.modules.jive.JiveFacade#create(
     * org.mule.modules.jive.JiveFacade.ServiceType, java.util.Map)
     */
    @Override
    public final Map<String, Object> create(final ServiceType type,
                                    final Map<String, Object> entity) {
        final Writer writer = new StringWriter();
        // validacion
        // directiva de conversion?
        map2xml(type, entity, writer);
        ClientResponse response = this.gateway.path(type.getCreateServiceName())
            .post(ClientResponse.class);
        // vamos a hacer el request
        // validar error
        return xml2map(new StringReader(writer.toString()));
    }

    /* Deletes an entity
     * @param type The service type, in this case indicating what entity to
     * delete
     * @param id The id of the entity to be deleted
     * @see org.mule.modules.jive.JiveFacade#delete(
     * org.mule.modules.jive.JiveFacade.ServiceType)
     */
    @Override
    public final Map<String, Object> delete(final ServiceType type,
        final String id) {
        final Writer writer = new StringWriter();
        // validacion
        // directiva de conversion?
        ClientResponse response = this.gateway.path(type.getDeleteServiceName()
            + "/" + id).delete(ClientResponse.class);
        // vamos a hacer el request
        // validar error
        return xml2map(new StringReader(writer.toString()));
    }



    ///////////////////////////Private methods//////////////////////////////////

    /**Maps a {@link Map} to an XML and writes it to the writer given.
     * @param type The service type
     * @param entity The map containing the entity data
     * @param writer The writer in which we'll write the xml
     * */
    private void map2xml(final ServiceType type,
                       final Map<String, Object> entity, final Writer writer) {
        try {
            final XMLStreamWriter w =
                    xmlOutputFactory.createXMLStreamWriter(writer);

            w.writeStartDocument();

            w.writeStartElement(type.getXmlRootElementName());
            writeXML(w, entity);
            w.writeEndElement();

            w.writeEndDocument();
        } catch (XMLStreamException e) {
            throw new UnhandledException(e);
        }
    }

    /**Writes the xml of the internal data.
     * @param w The writer in which it'll write the xml
     * @param model The entity
     * @throws XMLStreamException When fails
     * */
    private void writeXML(final XMLStreamWriter w,
                   final Map<String, Object> model) throws XMLStreamException {
        final Set<Entry<String, Object>> entries = model.entrySet();
        for (final Entry<String, Object> entry : entries) {
                w.writeStartElement(entry.getKey());
                if (!HashMap.class.isInstance(entry.getValue())) {
                    w.writeCharacters(entry.getValue().toString());
                } else {
                    writeXML(w, (HashMap<String, Object>)entry.getValue());
                }
                w.writeEndElement();
        }
    }

    /**Maps an xml from a {@link Reader} to a {@link Map}.
     * @param reader The {@link Reader} with the xml data
     * @return The map with the entity
     * */
    private Map<String, Object> xml2map(final Reader reader) {
        final Map<String, Object> ret = new HashMap<String, Object>();
        final Stack<Map<String, Object>> maps =
            new Stack<Map<String, Object>>();
        Map<String, Object> current = ret;

        try {
            final XMLStreamReader r =
                xmlInputFactory.createXMLStreamReader(reader);
            StringBuilder lastText = new StringBuilder();
            String currentElement = null;
            while (r.hasNext()) {
                final int eventType = r.next();
                if (eventType == CHARACTERS || eventType == CDATA
                        || eventType == SPACE
                        || eventType == ENTITY_REFERENCE) {
                    lastText.append(r.getText());
                } else if (eventType == PROCESSING_INSTRUCTION
                        || eventType == COMMENT) {
                    // skip
                } else if (eventType == END_DOCUMENT) {
                    break;
                } else if (eventType == START_ELEMENT) {
                    if (currentElement != null) {
                        maps.push(current);
                        final Map<String, Object> map =
                            new HashMap<String, Object>();
                        current.put(currentElement, map);
                        current = map;
                    }
                    currentElement = r.getLocalName();
                } else if (eventType == END_ELEMENT) {
                    if (currentElement == null) {
                        current = maps.pop();
                    } else {
                        current.put(currentElement, lastText.toString().trim());
                        currentElement = null;
                        lastText = new StringBuilder();
                    }
                } else {
                    throw new XMLStreamException("Unexpected event type "
                        + eventType);
                }
            }
            return ret;
        } catch (XMLStreamException e) {
            throw new UnhandledException(e);
        }
    }

    /**Creates the client.
     * @return The jersey client
     * */
    private Client createClient() {
        final ClientConfig config = new DefaultClientConfig();
        return Client.create(config);
    }

    /**Creates the webresource.
     * @param gatewayUri The resource uri
     * @param client The jersey client
     * */
    private void createGateway(final String gatewayUri, final Client client) {
        Validate.notNull(client, "Client cannot be empty");
        Validate.notEmpty(gatewayUri, "Gateway cannot be empty");
        this.gateway = client.resource(gatewayUri);
    }

}
