/**
 * Mule Development Kit Copyright 2010-2011 (c) MuleSoft, Inc. All rights
 * reserved. http://www.mulesoft.com
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

/**
 * This file was automatically generated by the Mule Development Kit
 */
package org.mule.modules.jive;

import static javax.xml.stream.XMLStreamConstants.*;

import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Module;
import org.mule.api.annotations.Processor;

import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.WebResource;
import com.sun.jersey.api.client.config.ClientConfig;
import com.sun.jersey.api.client.config.DefaultClientConfig;

import java.io.Reader;
import java.io.StringReader;
import java.io.StringWriter;
import java.io.Writer;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Stack;

import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;

import org.apache.commons.lang.UnhandledException;

@Module(name = "jive", namespace = "http://repository.mulesoft.org/releases/org/mule/modules/mule-module-jive", schemaLocation = "http://repository.mulesoft.org/releases/org/mule/modules/mule-module-jive/1.0-SNAPSHOT/mule-jive.xsd")
public class JiveModule implements JiveFacade {
    private WebResource gateway;

    @Configurable
    private String myProperty;

    public void setMyProperty(String myProperty) {
        this.myProperty = myProperty;
    }
    
    @Processor
    public String myProcessor(String content) {
        /*
         * MESSAGE PROCESSOR CODE GOES HERE
         */

        return content;
    }

    @Override
    public Map<String, Object> callService(final ServiceType type, final Map<String, Object> entity) {
        final Writer writer = new StringWriter();
        // validacion
        // directiva de conversion?
        map2xml(type, entity, writer);
        // vamos a hacer el request
        // validar error
        return xml2map(new StringReader(writer.toString()));
    }

    enum ACTION {
        CREATE,
    }

    private final XMLOutputFactory xmlOutputFactory = XMLOutputFactory.newInstance();
    private final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();

    private void map2xml(ServiceType type, final Map<String, Object> entity, Writer writer) {
        try {
            final XMLStreamWriter w = 
                    xmlOutputFactory.createXMLStreamWriter(writer);

            w.writeStartDocument();

            w.writeStartElement(type.getXmlRootElementName());
            writeXML(w, entity);
            w.writeEndElement();

            w.writeEndDocument();
        } catch (XMLStreamException e) {
            throw new UnhandledException(e);
        }
    }

    private void writeXML(XMLStreamWriter w, Map<String, Object> model) throws XMLStreamException {
        final Set<Entry<String, Object>> entries = model.entrySet();
        for (final Entry<String, Object> entry : entries) {
                w.writeStartElement(entry.getKey());
                if (!HashMap.class.isInstance(entry.getValue())) {
                    w.writeCharacters(entry.getValue().toString());
                } else {
                    writeXML(w, (HashMap<String, Object>)entry.getValue());
                }
                w.writeEndElement();
        }
    }

    private Map<String, Object> xml2map(Reader reader) {
        final Map<String, Object> ret = new HashMap<String, Object>();
        final Stack<Map<String, Object>> maps = new Stack<Map<String,Object>>();
        Map<String, Object> current = ret;
        
        try {
            final XMLStreamReader r = xmlInputFactory.createXMLStreamReader(reader);
            StringBuilder lastText = new StringBuilder();
            String currentElement = null;
            while (r.hasNext()) {
                final int eventType = r.next();
                if (eventType == CHARACTERS || eventType == CDATA
                        || eventType == SPACE
                        || eventType == ENTITY_REFERENCE) {
                    lastText.append(r.getText());
                    
                } else if (eventType == PROCESSING_INSTRUCTION
                        || eventType == COMMENT) {
                    // skip
                } else if (eventType == END_DOCUMENT) {
                    break;
                } else if (eventType == START_ELEMENT) {
                    if(currentElement != null) {
                        maps.push(current);
                        final Map<String, Object> map = new HashMap<String, Object>();
                        current.put(currentElement, map);
                        current = map;
                    }
                    currentElement = r.getLocalName();
                } else if (eventType == END_ELEMENT) {
                    if(currentElement == null) {
                        current = maps.pop();
                    } else {
                        current.put(currentElement, lastText.toString().trim());
                        currentElement = null;
                        lastText = new StringBuilder();
                    }
//                  throw new XMLStreamException("element text content may not contain START_ELEMENT");
                } else {
                    throw new XMLStreamException("Unexpected event type " + eventType);
                }
            }
            return ret;
        } catch (XMLStreamException e) {
            throw new UnhandledException(e);
        }
    }

    /**Creates the client.
     * @return The jersey client
     * */
    private Client createClient() {
        final ClientConfig config = new DefaultClientConfig();
        return Client.create(config);
    }

    /* Call service when no map is required.
     * @see org.mule.modules.jive.JiveFacade#callService(
     * org.mule.modules.jive.JiveFacade.ServiceType)
     */
    @Override
    public final Map<String, Object> callService(final ServiceType type) {
        return null;
    }

}
